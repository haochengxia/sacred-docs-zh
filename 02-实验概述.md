# 实验概述

实验是Sacred框架的核心类。本节将概述其功能以及如何使用它。

## 创建一个实验

要创建一个实验，只需实例化它并添加主要方法：

```python
from sacred import Experiment
ex = Experiment()

@ex.main
def my_main():
    pass
```

使用 @ex.main 装饰的函数是实验的主要函数。如果你运行实验，它将被执行，并且也用于确定实验的源文件。

建议使用 @ex.automain 来代替 @ex.main。这将自动运行实验，如果你执行该文件。它等同于以下：

```python
from sacred import Experiment
ex = Experiment()

@ex.main
def my_main():
    pass

if __name__ == '__main__':
    ex.run_commandline()
```

注意

为了使这个功能正常运行，automain函数需要在文件的末尾。否则，当实验运行时，它下面的所有内容还没有定义。

## 运行实验

运行实验的最简单方法是使用命令行。这需要你使用 automain（或等效物）。然后你只需执行实验的python文件，并使用强大的命令行界面。

你也可以直接从python运行你的实验。这特别有用，如果你想多次运行它，并使用不同的配置。假设你的实验在一个叫做 my_experiment.py 的文件中。然后你可以这样导入它并运行：

```python
from my_experiment import ex

r = ex.run()
```

警告

默认情况下，Sacred实验在交互式环境（如REPL或Jupyter笔记本）中运行会失败。这是一个预期的安全措施，因为在这些环境中无法确保可重复性。如有需要，可以通过将interactive=True传递给实验来取消此保护，如下所示：

```python
ex = Experiment('jupyter_ex', interactive=True)
```

run函数接受config_updates，以指定此次运行的配置应如何更改。它应该是一个（可能是嵌套的）字典，包含你希望更新的所有值。有关更多信息，请参见Configuration：

```python
from my_experiment import ex

r = ex.run(config_updates={'foo': 23})
```

注意

每次运行实验时，都会创建一个Run对象（这也是ex.run()返回的对象）。它包含一些关于该运行的信息（例如最终配置和后来的结果），并负责发出所有观察实验的事件。

在实验运行时，你可以通过接受任何Captured Functions中的特殊 _run 参数来访问它。这也用于保存自定义信息。

## 配置

有多种方式可以向你的实验添加配置。最简单的方式是通过Config Scopes：

```python
@ex.config
def my_config():
    foo = 42
    bar = 'baz'
```

该函数的局部变量被收集起来，形成了实验的配置。你可以充分利用Python的功能来定义这种方式的配置。参数甚至可以相互依赖。

注意

只有可以JSON序列化的变量（即数字、字符串、列表、元组、字典）才会成为配置的一部分。其他变量将被忽略。

如果你认为这里有太多的魔法，你可以始终使用一个普通字典来添加配置，或者，如果你愿意，你也可以直接从文件中加载配置条目。

当然，你也可以将它们全部组合在一起，甚至可以有多个每种类型。它们会按照你添加它们的顺序执行，并可能覆盖彼此的值。

## 捕获函数

要使用配置值，你只需要捕获一个函数，并接受配置值作为参数。现在，每当你调用该函数时，将自动从当前配置中检索参数：

```python
@ex.capture
def some_function(a, b):
    print(a + b)

@ex.main
def my_main():
    some_function()
```

在这个例子中，`some_function()`将查找`a`和`b`的值。这些值必须在当前配置中有定义。你可以通过直接传递它们来覆盖自动填充的参数。

注意

捕获函数可以接受来自配置的任何参数，并在每次以下是这段文档的中文翻译：

配置值优先于默认值。因此在上述示例中，`bar=10` 从未使用过，因为在配置中有一个值 `bar = 'baz'`。

观察实验
Sacred中的实验会收集很多关于运行的信息，比如：

- 实验开始和结束的时间
- 使用的配置
- 结果或发生的任何错误
- 运行的机器的基本信息
- 实验依赖的包及其版本
- 所有导入的本地源文件
- 使用 `ex.open_resource` 打开的文件
- 使用 `ex.add_artifact` 添加的文件

要访问这些信息，你可以使用观察者接口。首先，你需要像这样添加一个观察者：

```python
from sacred.observers import MongoObserver

ex.observers.append(MongoObserver())
```

`MongoObserver` 是Sacred默认提供的观察者之一。它连接到 MongoDB，然后将所有这些信息放入名为 `experiments` 的集合的一个文档中。你也可以如下从命令行接口添加此观察者：

```bash
>> python my_experiment.py -m my_database
```

欲了解更多信息，请参阅 “观察实验”。

捕获 stdout / stderr
Sacred试图捕获所有输出并将这些信息传输给观察者。此行为是可配置的，可以在三种模式中进行：无（no）、系统（sys）和文件描述符（fd）。此模式可以从命令行或设置中设置。

在无模式下，不会捕获任何输出。如果没有向实验添加观察者，这就是默认行为。

如果捕获模式设置为系统，那么sacred将捕获写入 sys.stdout 和 sys.stderr 的所有输出，如打印语句、堆栈跟踪和日志。在此模式下，可能无法捕获系统调用、C扩展或子进程的输出。这是Windows的默认行为。

最后，文件描述符模式在文件描述符级别捕获输出，并应包括由程序或任何子进程产生的所有输出。这是Linux和OSX的默认行为。

捕获的输出包含所有打印的字符，行为像文件而不像终端。有时这是不需要的，例如当输出包含大量实时更新，如进度条。为防止捕获的输出保留写入控制台的每个更新，可以向实验添加捕获的输出过滤器，如下所示：

```python
from sacred.utils import apply_backspaces_and_linefeeds

ex.captured_out_filter = apply_backspaces_and_linefeeds
```

在这里 `apply_backspaces_and_linefeeds` 是一个简单的函数，它像在终端中一样解释所有退格和换行符，并返回修改后的文本。任何接受字符串作为输入并输出（修改后的）字符串的函数都可以用作捕获的输出过滤器。有关简单示例，请参阅 `examples/captured_out_filter.py`。

中断和失败的实验
如果运行被中断（例如 Ctrl+C）或出现异常，Sacred将收集堆栈跟踪和失败时间，并将它们报告给观察者。结果条目将其状态设置为中断（INTERRUPTED）或失败（FAILED）。这可以快速看到非成功运行的原因，并使以后可以调查错误。

检测硬故障
有时，实验可能会失败，但没有抛出异常（例如电源丢失，内核恐慌等）。在这种情况下，无法将失败记录到数据库，其状态仍将是运行（RUNNING）。以这种方式失败的运行最容易通过查看它们的心跳时间检测到：每个正在运行的实验在规定的间隔（默认每10秒）向其观察者报告，并更新心跳时间以及捕获的 stdout 和 info 字典（参见 "保存自定义信息"）。所以，如果心跳时间比该间隔更远，那么运行可以被认为是已经停止。

调试
如果发生异常，Sacred默认会通过删除所有Sacred内部调用来过滤堆栈跟踪。堆栈跟踪当然也会保存在数据库中（如果添加了合适的观察者）。这有助于快速发现你自己代码中的错误。然而，如果你想使用调试器，需要禁用堆栈跟踪过滤，因为它与像pdb这样的调试器不兼容。

如果你想在实验中使用调试器，有两个选项：

禁用堆栈跟踪过滤
可以通过 `-d` 堆栈跟踪过滤可以通过 -d 标志来取消激活。这时 Sacred 不会干扰异常，任何调试器都可以正常处理它。

事后调试
为方便起见，Sacred 还支持通过 -D 标志直接附加事后调试器 pdb。如果设置了此选项并发生异常，Sacred 将自动启动 pdb 调试器以调查错误并与堆栈交互。

自定义中断
有时候，为了中断实验，自定义中断原因非常有用。一个例子是，如果实验有限的时间预算，当实验因超出时间限制而停止时，应在数据库条目中反映出来。

针对这些情况，Sacred 提供了一个特殊的基础异常 sacred.utils.SacredInterrupt，可以用于提供自定义状态码。如果引发了从此异常派生的异常，则中断运行的状态将设置为该代码。

对于上述超时用例，有 sacred.utils.TimeoutInterrupt 异常，其状态代码为 TIMEOUT。但是，任何状态代码都可以使用，只需创建一个继承自 sacred.utils.SacredInterrupt 并定义 STATUS 成员的自定义异常，如下所示：

from sacred.utils import SacredInterrupt

class CustomInterrupt(SacredInterrupt)
    STATUS = 'MY_CUSTOM_STATUS'

当在任何运行期间引发此异常时，其状态将设置为 MY_CUSTOM_STATUS。

排队运行
Sacred 还支持通过传递 Queue 标志（-q/--queue）来排队运行。这不会运行实验，而只会创建一个数据库条目，其中包含启动运行所需的所有信息。此功能可用于具有分布式工作池的情况，这些工作池从数据库中获取配置并运行它们。然而，目前还没有针对此工作流程的进一步支持。